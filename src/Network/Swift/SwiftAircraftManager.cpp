// SwiftAircraftManager.cpp - Manager class for aircrafts generated by swift
//
// Copyright (C) 2019 - swift Project Community / Contributors (http://swift-project.org/)
// Adapted to Flightgear by Lars Toenning <dev@ltoenning.de>
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation; either version 2 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#include "SwiftAircraftManager.h"
#include "SwiftAircraft.h"
#include <Main/globals.hxx>

FGSwiftAircraftManager::FGSwiftAircraftManager()
{
}

FGSwiftAircraftManager::~FGSwiftAircraftManager()
{
}

bool FGSwiftAircraftManager::addPlane(std::string callsign, std::string modelString)
{
    if (aircraftByCallsign.find(callsign) != aircraftByCallsign.end())
        return false;

    const char* typeString = "swift";
    SGPropertyNode* root = globals->get_props()->getNode("ai/models",true);
    SGPropertyNode* p;
    int i;
    for(i = 0; i < 10000; i++){
        p = root->getNode(typeString,i,false);

        if(!p || !p->getBoolValue("valid",false))
            break;
    }
    p = root->getNode(typeString,i,true);
    p->setIntValue("id",i);
    FGSwiftAircraft* curAircraft = new FGSwiftAircraft(callsign, modelString, p);
    aircraftByCallsign.insert(std::pair<std::string, FGSwiftAircraft*>(callsign, curAircraft));
    return true;
}

void FGSwiftAircraftManager::updatePlanes(std::vector<std::string> callsigns, std::vector<SGGeod> positions, std::vector<SGVec3d> orientations, std::vector<double> groundspeeds, std::vector<bool> onGrounds)
{
	for (int i = 0; i < callsigns.size(); i++) {
        auto it = aircraftByCallsign.find(callsigns.at(i));
		if (it != aircraftByCallsign.end()) {
            it->second->updatePosition(positions.at(i), orientations.at(i), groundspeeds.at(i));
		}
	}

}

void FGSwiftAircraftManager::getRemoteAircraftData(std::vector<std::string>& callsigns, std::vector<double>& latitudesDeg, std::vector<double>& longitudesDeg, std::vector<double>& elevationsM, std::vector<double>& verticalOffsets) const
{
    const auto requestedCallsigns = callsigns;
    callsigns.clear();
    latitudesDeg.clear();
    longitudesDeg.clear();
    elevationsM.clear();
    verticalOffsets.clear();

	for (int i = 0; i < requestedCallsigns.size(); i++) {
        auto it = aircraftByCallsign.find(requestedCallsigns.at(i));
        if (it != aircraftByCallsign.end()) {
            double latDeg = it->second->getLatDeg();
            double lonDeg = it->second->getLongDeg();
            double groundElevation = it->second->getGroundElevation();
            double fudgeFactor     = it->second->getFudgeFactor();

            callsigns.push_back(requestedCallsigns.at(i));
            latitudesDeg.push_back(latDeg);
            longitudesDeg.push_back(lonDeg);
            elevationsM.push_back(groundElevation);
            verticalOffsets.push_back(0);
        }
	}

}

void FGSwiftAircraftManager::removePlane(std::string callsign)
{
    auto it = aircraftByCallsign.find(callsign);
    if (it != aircraftByCallsign.end()) {
		delete it->second;
        aircraftByCallsign.erase(it);
    }
}

void FGSwiftAircraftManager::removeAllPlanes()
{
    for (auto it = aircraftByCallsign.begin(); it != aircraftByCallsign.end(); ++it) {
        delete it->second;
        aircraftByCallsign.erase(it);
    }
}
